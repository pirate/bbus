---
title: EventBus
description: EventBus constructors, configuration, and core methods.
---

`EventBus` is the central runtime for handler registration, event emit, history lookup, and lifecycle control.

## `EventBus(...)`

<Tabs>
<Tab title="Python">

```python
EventBus(
    name: str | None = None,
    event_concurrency: Literal['global-serial', 'bus-serial', 'parallel'] | str | None = None,
    event_handler_concurrency: Literal['serial', 'parallel'] | str = 'serial',
    event_handler_completion: Literal['all', 'first'] | str = 'all',
    max_history_size: int | None = 50,
    max_history_drop: bool = False,
    event_timeout: float | None = 60.0,
    event_slow_timeout: float | None = 300.0,
    event_handler_slow_timeout: float | None = 30.0,
    event_handler_detect_file_paths: bool = True,
    middlewares: Sequence[EventBusMiddleware] | None = None,
)
```

</Tab>
<Tab title="TypeScript">

```ts
new EventBus(name?: string, options?: {
  id?: string
  max_history_size?: number | null
  max_history_drop?: boolean
  event_concurrency?: 'global-serial' | 'bus-serial' | 'parallel' | null
  event_timeout?: number | null
  event_slow_timeout?: number | null
  event_handler_concurrency?: 'serial' | 'parallel' | null
  event_handler_completion?: 'all' | 'first'
  event_handler_slow_timeout?: number | null
  event_handler_detect_file_paths?: boolean
})
```

</Tab>
</Tabs>

### Shared configuration semantics

| Option | Description |
| --- | --- |
| `name` | Human-readable bus name used in logs/labels. |
| `event_concurrency` | Event scheduling policy across queue processing (`global-serial`, `bus-serial`, `parallel`). |
| `event_handler_concurrency` | How handlers for one event execute (`serial` vs `parallel`). |
| `event_handler_completion` | Completion mode (`all` waits for all handlers, `first` resolves on first successful result). |
| `event_timeout` | Default outer timeout budget for event/handler execution. |
| `event_slow_timeout` | Slow-event warning threshold. |
| `event_handler_slow_timeout` | Slow-handler warning threshold. |
| `event_handler_detect_file_paths` | Whether to capture source path metadata for handlers. |
| `max_history_size` | Maximum retained history (`null` = unbounded, `0` = keep only in-flight). |
| `max_history_drop` | If `true`, drop oldest history entries when full; if `false`, reject new emits at limit. |

## Runtime state

Both implementations expose equivalent runtime state:

- Bus identity: `id`, `name`, `label`
- Registered handlers and indexes
- Event history and pending queue
- In-flight tracking
- Locking/concurrency runtime objects

## `on(...)`

Registers a handler for an event key (`EventClass`, event type string, or `'*'`).

<Tabs>
<Tab title="Python">

```python
bus.on(UserEvent, handler)
bus.on('UserEvent', handler)
bus.on('*', wildcard_handler)
```

</Tab>
<Tab title="TypeScript">

```ts
bus.on(UserEvent, handler)
bus.on('UserEvent', handler)
bus.on('*', wildcardHandler)
```

</Tab>
</Tabs>

## `off(...)`

Unregisters handlers by event key, handler function/reference, or handler id.

<Tabs>
<Tab title="Python">

```python
bus.off(UserEvent, handler)
bus.off(UserEvent)   # remove all handlers for UserEvent
bus.off('*')         # remove all wildcard handlers
```

</Tab>
<Tab title="TypeScript">

```ts
bus.off(UserEvent, handler)
bus.off(UserEvent)
bus.off('*')
```

</Tab>
</Tabs>

## `emit(...)`

`emit(...)` enqueues synchronously and returns the pending event immediately.

<Tabs>
<Tab title="Python">

```python
event = bus.emit(MyEvent(data='x'))
result = await event.event_result()
```

</Tab>
<Tab title="TypeScript">

```ts
const event = bus.emit(MyEvent({ data: 'x' }))
const result = await event.first()
```

</Tab>
</Tabs>

## `find(...)`

`find(...)` supports history lookup, optional future waiting, predicate filtering, and parent/child scoping.

<Tabs>
<Tab title="Python">

```python
event = await bus.find(ResponseEvent)  # history lookup by default
future = await bus.find(ResponseEvent, past=False, future=5)
child = await bus.find(ChildEvent, child_of=parent_event, future=5)
```

</Tab>
<Tab title="TypeScript">

```ts
const event = await bus.find(ResponseEvent)
const future = await bus.find(ResponseEvent, { past: false, future: 5 })
const child = await bus.find(ChildEvent, { child_of: parentEvent, future: 5 })
```

</Tab>
</Tabs>

## Lifecycle helpers

### Wait for idle

<Tabs>
<Tab title="Python">

```python
await bus.wait_until_idle()
await bus.wait_until_idle(timeout=5)
```

</Tab>
<Tab title="TypeScript">

```ts
await bus.waitUntilIdle()
await bus.waitUntilIdle(5)
```

</Tab>
</Tabs>

### Parent/child relationship checks

<Tabs>
<Tab title="Python">

```python
bus.event_is_child_of(child_event, parent_event)
bus.event_is_parent_of(parent_event, child_event)
```

</Tab>
<Tab title="TypeScript">

```ts
bus.eventIsChildOf(childEvent, parentEvent)
bus.eventIsParentOf(parentEvent, childEvent)
```

</Tab>
</Tabs>

### Serialization and teardown

<Tabs>
<Tab title="Python">

```python
await bus.stop(timeout=1.0)
await bus.stop(clear=True)
```

</Tab>
<Tab title="TypeScript">

```ts
const snapshot = bus.toJSON()
const restored = EventBus.fromJSON(snapshot)
bus.destroy()
```

</Tab>
</Tabs>

## Timeout and precedence

Shared precedence model:

1. Handler override
2. Event override
3. Bus default

Effective handler timeout is capped by event timeout when both are set.
