---
title: EventResult
description: EventResult fields, status, and handler execution results.
---

Each handler execution for an event produces one `EventResult`.

You usually access results through `event.event_results` (or high-level event helper methods), but this page documents the underlying object.

## Common fields

- `id`: unique result id
- `status`: `pending | started | completed | error`
- `result`: handler return value (typed by event result schema/type)
- `error`: captured exception/error when handler fails
- `started_at`, `completed_at` (`None`/`null` until the handler starts/completes)
- TypeScript also includes `started_ts` / `completed_ts` (`number | null`)
- `event_children`: child events emitted from inside this handler execution
- Handler metadata (`handler_id`, `handler_name`, `handler_file_path`, bus label/id/name)

## Await semantics

Awaiting an `EventResult` resolves to handler return value or raises captured failure.

<Tabs>
<Tab title="Python">

```python
entry = event.event_results[some_handler_id]
value = await entry
```

</Tab>
<Tab title="TypeScript">

```ts
const [, entry] = Array.from(event.event_results.entries())[0]
const value = entry.result
```

</Tab>
</Tabs>

## Internal lifecycle methods

Used by bus internals; generally not needed for normal app code.

<Tabs>
<Tab title="Python">

```python
# internal methods used by EventBus
await entry.run_handler(...)
entry.update(status='started' | 'completed' | 'error', result=..., error=...)
```

</Tab>
<Tab title="TypeScript">

```ts
entry.markStarted()
entry.markCompleted(result)
entry.markError(error)
await entry.runHandler(...)
entry.signalAbort(error)
entry.linkEmittedChildEvent(childEvent)
```

</Tab>
</Tabs>

## Scope stack ordering

`EventResult` execution is intentionally layered as nested scopes/wrappers.

<Tabs>
<Tab title="Python">

- `locks.with_handler_lock(...)`
- `with_timeout(...)`
- `with_slow_monitor(...)`
- `with_handler_execution_context(...)`
- `call_handler(...)`

</Tab>
<Tab title="TypeScript">

- `withHandlerLock(...)` (acquired by `BaseEvent.runHandlers(...)` before `runHandler(...)`)
- `withHandlerExecutionContext(...)`
- `runWithAsyncContext(...)`
- `withTimeout(...)`
- `withSlowMonitor(...)`
- `runWithAbortMonitor(...)`

</Tab>
</Tabs>

## Serialization

<Tabs>
<Tab title="Python">

```python
payload = entry.model_dump(mode='json')
print(payload)
# {
#   "id": "0190...",
#   "status": "completed",
#   "event_id": "018f...",
#   "handler_id": "018g...",
#   "handler_name": "on_user_created",
#   "result": {"user_id": "u_123"},
#   "error": None,
#   "...": "..."
# }

restored = EventResult.model_validate(payload)
```

</Tab>
<Tab title="TypeScript">

```ts
const payload = entry.toJSON()
console.log(payload)
// {
//   id: '0190...',
//   status: 'completed',
//   event_id: '018f...',
//   handler: { id: '018g...', handler_name: 'onUserCreated', ... },
//   result: { user_id: 'u_123' },
//   error: undefined,
//   ...
// }

const restored = EventResult.fromJSON(event, payload)
```

</Tab>
</Tabs>
