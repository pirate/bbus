---
title: BaseEvent
description: BaseEvent schema fields, lifecycle, and result helpers.
---

`BaseEvent` is the typed payload + runtime state object that flows through the bus.

Use subclassing (Python) or `BaseEvent.extend(...)` (TypeScript) to define event payload fields.

## Defining events

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent

class FooCreateEvent(BaseEvent[str]):
    id: str | None = None
    name: str
    age: int
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent } from 'bubus'
import { z } from 'zod'

const FooCreateEvent = BaseEvent.extend('FooCreateEvent', {
  id: z.string().nullable().optional(),
  name: z.string(),
  age: z.number(),
  event_result_type: z.string(),
})
```

</Tab>
</Tabs>

## Core metadata fields

Common event metadata fields available in both runtimes:

- `event_id`: unique UUIDv7
- `event_type`: event name/type key
- `event_version`: payload version marker
- `event_result_type`: expected handler return schema/type
- `event_timeout`: per-event timeout override
- `event_handler_timeout`: per-handler timeout cap override
- `event_handler_slow_timeout`: per-handler slow warning threshold
- `event_concurrency`: event scheduling mode override
- `event_handler_concurrency`: handler scheduling mode override
- `event_handler_completion`: handler completion strategy override

## Runtime fields

- `event_status`: pending/started/completed
- `event_created_at`, `event_started_at`, `event_completed_at`
- `event_parent_id`: parent event link
- `event_path`: buses traversed
- `event_results`: per-handler result entries
- Child-event tracking (`event_children`/descendants)

## Completion model

Events are returned in pending state from `dispatch()/emit()`, then complete asynchronously.

<Tabs>
<Tab title="Python">

```python
pending = bus.dispatch(MyEvent())
completed = await pending
value = await completed.event_result()
```

</Tab>
<Tab title="TypeScript">

```ts
const pending = bus.emit(MyEvent({}))
const completed = await pending.done()
const value = completed.first_result
```

</Tab>
</Tabs>

## Result access helpers

### First successful result

<Tabs>
<Tab title="Python">

```python
value = await event.first()
# equivalent: await event.event_result(...) with first-completion mode
```

</Tab>
<Tab title="TypeScript">

```ts
const value = await event.first()
```

</Tab>
</Tabs>

### All results

<Tabs>
<Tab title="Python">

```python
by_handler = await event.event_results_by_handler_id()
items = await event.event_results_list()
flat_dict = await event.event_results_flat_dict(raise_if_conflicts=False)
flat_list = await event.event_results_flat_list()
```

</Tab>
<Tab title="TypeScript">

```ts
const all = event.all_results
const first = event.first_result
const last = event.last_result
const errors = event.event_errors
```

</Tab>
</Tabs>

## Reuse/reset

You can create a fresh pending copy for re-dispatch.

<Tabs>
<Tab title="Python">

```python
fresh = event.reset()
```

</Tab>
<Tab title="TypeScript">

```ts
const fresh = event.reset()
```

</Tab>
</Tabs>

## Serialization

Events are JSON-serializable in both implementations for bridge and cross-runtime workflows.

<Tabs>
<Tab title="Python">

```python
payload = event.model_dump(mode='json')
restored = type(event).model_validate(payload)
```

</Tab>
<Tab title="TypeScript">

```ts
const payload = event.toJSON()
const restored = BaseEvent.fromJSON(payload)
```

</Tab>
</Tabs>

## Notes

- Keep custom payload field names away from `event_*` reserved metadata names.
- `event_result_type` drives handler return validation in both runtimes.
- Parent-child tracking is automatic when events are emitted from handlers.
