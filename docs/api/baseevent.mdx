---
title: BaseEvent
description: BaseEvent schema fields, lifecycle, and result helpers.
---

`BaseEvent` is the typed payload + runtime state object that flows through the bus.

Use subclassing (Python) or `BaseEvent.extend(...)` (TypeScript) to define event payload fields.

## Defining events

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent

class FooCreateEvent(BaseEvent[str]):
    id: str | None = None
    name: str
    age: int
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent } from 'bubus'
import { z } from 'zod'

const FooCreateEvent = BaseEvent.extend('FooCreateEvent', {
  id: z.string().nullable().optional(),
  name: z.string(),
  age: z.number(),
  event_result_type: z.string(),
})
```

</Tab>
</Tabs>

## Core metadata fields

Common event metadata fields available in both runtimes:

- `event_id`: unique UUIDv7
- `event_type`: event name/type key
- `event_version`: payload version marker
- `event_result_type`: expected handler return schema/type
- `event_timeout`: per-event timeout override (`None`/`null` means use the current processing bus default)
- `event_handler_timeout`: per-handler timeout cap override
- `event_handler_slow_timeout`: per-handler slow warning threshold
- `event_concurrency`: event scheduling mode override (`None`/`null` means use the current processing bus default)
- `event_handler_concurrency`: handler scheduling mode override (`None`/`null` means use the current processing bus default)
- `event_handler_completion`: handler completion strategy override (`None`/`null` means use the current processing bus default)

## Runtime fields

- `event_status`: pending/started/completed
- `event_created_at`, `event_started_at`, `event_completed_at`
- `event_started_at` / `event_completed_at` are `None` (Python) / `null` (TypeScript) until set
- `event_parent_id` and `event_emitted_by_handler_id` are `None` / `null` when unset
- TypeScript also exposes `event_created_ts`, `event_started_ts`, `event_completed_ts` (`number | null` for started/completed timestamps)
- `event_path`: buses traversed
- `event_results`: per-handler result entries
- Child-event tracking (`event_children`/descendants)

## Completion model

Events are returned in pending state from `emit()`, then complete asynchronously.

<Tabs>
<Tab title="Python">

```python
pending = bus.emit(MyEvent())
completed = await pending
value = await completed.event_result()
```

</Tab>
<Tab title="TypeScript">

```ts
const pending = bus.emit(MyEvent({}))
const completed = await pending.done()
const value = completed.event_result
```

</Tab>
</Tabs>

## Result access helpers

### `first()`

<Tabs>
<Tab title="Python">

```python
value = await event.first()
# equivalent: await event.event_result(...) with first-completion mode
```

</Tab>
<Tab title="TypeScript">

```ts
const value = await event.first()
```

</Tab>
</Tabs>

### All results

<Tabs>
<Tab title="Python">

```python
items = await event.event_results_list()
by_handler = {handler_id: result.result for handler_id, result in event.event_results.items()}
```

</Tab>
<Tab title="TypeScript">

```ts
const items = await event.eventResultsList()
const filtered = await event.eventResultsList((result) => typeof result === 'string', {
  raise_if_any: false,
  raise_if_none: true,
})
const all = event.all_results
const first = event.event_result
const last = event.last_result
const errors = event.event_errors
```

</Tab>
</Tabs>

## Resetting an event

You can create a fresh pending copy for re-emit.

<Tabs>
<Tab title="Python">

```python
fresh = event.event_reset()
```

</Tab>
<Tab title="TypeScript">

```ts
const fresh = event.eventReset()
```

</Tab>
</Tabs>

## Serialization

Events are JSON-serializable in both implementations for bridge and cross-runtime workflows.

<Tabs>
<Tab title="Python">

```python
payload = event.model_dump(mode='json')
print(payload)
# {
#   "event_id": "0190...",
#   "event_type": "CreateUserEvent",
#   "event_status": "pending",
#   "event_result_type": {"type": "object", "...": "..."},
#   "email": "someuser@example.com",
#   "...": "..."
# }

restored = type(event).model_validate(payload)
```

</Tab>
<Tab title="TypeScript">

```ts
const payload = event.toJSON()
console.log(payload)
// {
//   event_id: '0190...',
//   event_type: 'CreateUserEvent',
//   event_status: 'pending',
//   event_result_type: { type: 'object', ... },
//   email: 'someuser@example.com',
//   ...
// }

const restored = BaseEvent.fromJSON(payload)
```

</Tab>
</Tabs>

## Notes

- Reserved names are validated in both runtimes:
  - `bus` and `first` are reserved runtime APIs and cannot be provided as payload fields.
  - Unknown `event_*` fields are rejected.
  - Known built-in `event_*` fields (for example `event_timeout`) can still be intentionally overridden in event definitions.
- `model_*` is also reserved:
  - Python: unknown `model_*` fields are rejected, but valid Pydantic namespace overrides (for example `model_config`) are allowed.
  - TypeScript: any `model_*` field is rejected.
- `event_result_type` drives handler return validation in both runtimes.
- Parent-child tracking is automatic when events are emitted from handlers.

## Reserved Fields

<Tabs>
<Tab title="Python">

```python
from pydantic import ConfigDict
from bubus import BaseEvent

class AllowedEvent(BaseEvent[None]):
    event_timeout: float | None = 30  # allowed built-in event_* override
    model_config = ConfigDict(extra='allow')  # allowed Pydantic model_* override

# rejected: unknown reserved prefixes
class InvalidEvent(BaseEvent[None]):
    event_some_field_we_dont_recognize: int = 1  # raises
    model_something_random: int = 2  # raises
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent } from 'bubus'
import { z } from 'zod'

const AllowedEvent = BaseEvent.extend('AllowedEvent', {
  event_timeout: 30, // allowed built-in event_* override
  payload: z.string(),
})

// rejected: unknown event_* and all model_*
BaseEvent.extend('InvalidEvent', {
  event_some_field_we_dont_recognize: 1, // throws
  model_something_random: 2, // throws
})
```

</Tab>
</Tabs>
