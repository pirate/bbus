---
title: Return Value Handling
description: Define typed handler returns and collect results from one emitted event.
---

Handler return values are captured in `EventResult` records and can be consumed as a single value or aggregated across handlers.

Repository example files:
- [`examples/simple.py`](https://github.com/pirate/bbus/blob/main/examples/simple.py)
- [`bubus-ts/examples/simple.ts`](https://github.com/pirate/bbus/blob/main/bubus-ts/examples/simple.ts)

## Typed return values

Use the event result type to enforce return typing across handlers.

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent, EventBus

class DoMathEvent(BaseEvent[int]):
    a: int
    b: int

def add(event: DoMathEvent) -> int:
    return event.a + event.b

bus = EventBus('AppBus')
bus.on(DoMathEvent, add)

event = await bus.emit(DoMathEvent(a=2, b=3))
result = await event.event_result()
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent, EventBus } from 'bubus'
import { z } from 'zod'

const DoMathEvent = BaseEvent.extend('DoMathEvent', {
  a: z.number(),
  b: z.number(),
  event_result_type: z.number(),
})

const bus = new EventBus('AppBus')
bus.on(DoMathEvent, (event) => event.a + event.b)

const event = bus.emit(DoMathEvent({ a: 2, b: 3 }))
await event.done()
const result = event.event_result
```

</Tab>
</Tabs>

## Aggregating multiple handler results

When multiple handlers respond to the same event, collect all results.

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent, EventBus

class GetConfigEvent(BaseEvent[dict]):
    pass

async def user_config(_: GetConfigEvent) -> dict:
    return {'debug': True, 'port': 8080}

async def system_config(_: GetConfigEvent) -> dict:
    return {'debug': False, 'timeout': 30}

bus = EventBus('AppBus')
bus.on(GetConfigEvent, user_config)
bus.on(GetConfigEvent, system_config)

event = await bus.emit(GetConfigEvent())
values = await event.event_results_list(raise_if_any=False, raise_if_none=False)
# [
#   {'debug': True, 'port': 8080},
#   {'debug': False, 'timeout': 30}
# ]

merged_config = {key: val for config in values for key, val in config.items()}
# {'debug': False, 'port': 8080, 'timeout': 30}
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent, EventBus } from 'bubus'
import { z } from 'zod'

const GetConfigEvent = BaseEvent.extend('GetConfigEvent', {
  event_result_type: z.record(z.string(), z.unknown()),
})

const bus = new EventBus('AppBus')
bus.on(GetConfigEvent, async () => ({ debug: true, port: 8080 }))
bus.on(GetConfigEvent, async () => ({ debug: false, timeout: 30 }))

const event = bus.emit(GetConfigEvent({}))
const values = await event.eventResultsList({ raise_if_any: false, raise_if_none: false })
// [
//   {debug: true, port: 8080},
//   {debug: false, timeout: 30}
// ]
const merged_config = values.reduce((acc, value) => {
  if (value && typeof value === 'object' && !Array.isArray(value)) {
    Object.assign(acc, value)
  }
  return acc
}, {})
// {debug: false, port: 8080, timeout: 30}
```

</Tab>
</Tabs>

## `event_results_list` / `eventResultsList` options

<Tabs>
<Tab title="Python">

```python
event_results_list(
    timeout: float | None = None,
    include: EventResultFilter = ...,
    raise_if_any: bool = True,
    raise_if_none: bool = True,
) -> list[Any]

# examples
await event.event_results_list(raise_if_any=False, raise_if_none=False)
await event.event_results_list(include=lambda event_result: isinstance(event_result.result, dict), raise_if_any=False)
await event.event_results_list(timeout=0.25)
```

</Tab>
<Tab title="TypeScript">

```ts
eventResultsList(
  include?: (result: EventResultType<this> | undefined, event_result: EventResult<this>) => boolean,
  options?: {
    timeout?: number | null
    include?: (result: EventResultType<this> | undefined, event_result: EventResult<this>) => boolean
    raise_if_any?: boolean
    raise_if_none?: boolean
  }
): Promise<Array<EventResultType<this> | undefined>>

// examples
await event.eventResultsList({ raise_if_any: false, raise_if_none: false })
await event.eventResultsList((result) => typeof result === 'object', { raise_if_any: false })
await event.eventResultsList({ timeout: 0.25 })
```

</Tab>
</Tabs>

- `raise_if_any`: raise if any handler ended with an error.
- `raise_if_none`: raise only when no handlers returned a valid value after filtering; it does not raise just because one handler returned `None`/`null`/`undefined`.
- Default filtering in both runtimes includes only completed, successful, non-empty scalar/object/list values (and excludes forwarded `BaseEvent` returns).

## Per-handler inspection

Both implementations keep per-handler result metadata in addition to `event_results_list` / `eventResultsList`.

<Tabs>
<Tab title="Python">

```python
by_name = {result.handler_name: result.result for result in event.event_results.values()}
```

</Tab>
<Tab title="TypeScript">

```ts
const byHandler = event.event_results
```

</Tab>
</Tabs>
