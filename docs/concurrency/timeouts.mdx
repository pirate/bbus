---
title: Timeout Enforcement
description: Configure execution deadlines and slow-warning thresholds at bus, event, and handler levels.
---

Timeout controls operate at three levels:

- Bus defaults (applies to all events/handlers unless overridden)
- Per-event overrides (applies to one emitted event instance)
- Per-handler overrides (applies to one handler registration)

Repository example files:
- [`examples/concurrency_options.py`](https://github.com/pirate/bbus/blob/main/examples/concurrency_options.py)
- [`bubus-ts/examples/concurrency_options.ts`](https://github.com/pirate/bbus/blob/main/bubus-ts/examples/concurrency_options.ts)
- [`examples/log_tree_demo.py`](https://github.com/pirate/bbus/blob/main/examples/log_tree_demo.py)
- [`bubus-ts/examples/log_tree_demo.ts`](https://github.com/pirate/bbus/blob/main/bubus-ts/examples/log_tree_demo.ts)

## Timeout types

### 1) Event timeout (`event_timeout`)

The outer execution budget for an event. This also acts as an upper cap for each handler run for that event.

### 2) Handler timeout (`event_handler_timeout` / `handler_timeout`)

A handler-specific timeout budget. The effective handler timeout is resolved from handler -> event -> bus, then capped by `event_timeout` when both are set.

### 3) Slow-warning thresholds (`event_slow_timeout`, `event_handler_slow_timeout`, `handler_slow_timeout`)

These emit warnings when work is taking longer than expected:

- `event_slow_timeout`: warns when event processing is still running past the threshold.
- `event_handler_slow_timeout` / `handler_slow_timeout`: warns when a handler run is still running past the threshold.

Slow thresholds are warnings, not forced cancellation.

## Where to set each value

| Level | Execution timeout fields | Slow-warning fields |
| --- | --- | --- |
| Bus | `event_timeout` | `event_slow_timeout`, `event_handler_slow_timeout` |
| Event | `event_timeout`, `event_handler_timeout` | `event_slow_timeout`, `event_handler_slow_timeout` |
| Handler | `handler_timeout` | `handler_slow_timeout` |

## Bus-level defaults

Set default budgets and warning thresholds once when creating a bus.

<Tabs>
<Tab title="Python">

```python
from bubus import EventBus

bus = EventBus(
    'TimeoutBus',
    event_timeout=30.0,
    event_slow_timeout=10.0,
    event_handler_slow_timeout=3.0,
)
```

</Tab>
<Tab title="TypeScript">

```ts
import { EventBus } from 'bubus'

const bus = new EventBus('TimeoutBus', {
  event_timeout: 30,
  event_slow_timeout: 10,
  event_handler_slow_timeout: 3,
})
```

</Tab>
</Tabs>

## Event-level overrides

Set per-event values when emitting an event instance.

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent

class WorkEvent(BaseEvent):
    pass

event = bus.emit(
    WorkEvent(
        event_timeout=8.0,
        event_handler_timeout=2.0,
        event_slow_timeout=4.0,
        event_handler_slow_timeout=1.0,
    )
)
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent } from 'bubus'

const WorkEvent = BaseEvent.extend('WorkEvent', {})

const event = bus.emit(
  WorkEvent({
    event_timeout: 8,
    event_handler_timeout: 2,
    event_slow_timeout: 4,
    event_handler_slow_timeout: 1,
  })
)
```

</Tab>
</Tabs>

## Handler-level overrides

Set per-handler timeout and slow-warning overrides at registration time (or by updating the returned handler metadata).

<Tabs>
<Tab title="Python">

```python
entry = bus.on(WorkEvent, slow_handler)
entry.handler_timeout = 1.5
entry.handler_slow_timeout = 0.5
```

</Tab>
<Tab title="TypeScript">

```ts
bus.on(WorkEvent, slowHandler, {
  handler_timeout: 1.5,
  handler_slow_timeout: 0.5,
})
```

</Tab>
</Tabs>

## Precedence rules

### Effective handler timeout

1. Resolve handler timeout source:
   - `handler_timeout` (handler level)
   - else `event_handler_timeout` (event level)
   - else bus `event_timeout`
2. Apply event cap:
   - effective timeout is `min(resolved_handler_timeout, event_timeout)` when both are set
   - if one is unset, the other value is used
   - if both are unset, no timeout is enforced

### Effective handler slow-warning threshold

Resolved in this order:

1. `handler_slow_timeout`
2. `event_handler_slow_timeout`
3. `event_slow_timeout`
4. bus `event_handler_slow_timeout`
5. bus `event_slow_timeout`

### Effective event slow-warning threshold

Resolved in this order:

1. `event_slow_timeout`
2. bus `event_slow_timeout`

## Execution scope ordering

Timeout and slow-monitor behavior is implemented as stacked runtime scopes. The ordering matters:

<Tabs>
<Tab title="Python">

```python
# EventBus.process_event(...)
async with locks.with_event_lock(...):
    async with asyncio.timeout(event_timeout):
        async with with_slow_monitor(event_slow_monitor):
            await event.event_run_handlers(...)

# EventResult.run_handler(...)
async with locks.with_handler_lock(...):
    async with event_result.with_timeout(event):
        async with with_slow_monitor(handler_slow_monitor):
            with eventbus.with_handler_execution_context(event, handler_id):
                await event_result.call_handler(...)
```

</Tab>
<Tab title="TypeScript">

```ts
// EventBus.processEvent(...)
await locks.withEventLock(event, () =>
  _runHandlersWithTimeout(event, pendingEntries, () =>
    withSlowMonitor(event.createSlowEventWarningTimer(), () =>
      scopedEvent.runHandlers(pendingEntries)
    )
  )
)

// BaseEvent.runHandlers(...) + EventResult.runHandler(...)
await locks.withHandlerLock(event, defaultHandlerConcurrency, async (handlerLock) => {
  await entry.runHandler(handlerLock)
})

await locks.withHandlerExecutionContext(result, async () => {
  await runWithAsyncContext(event.eventGetDispatchContext() ?? null, async () => {
    await withTimeout(handlerTimeout, onHandlerTimeout, () =>
      withSlowMonitor(handlerSlowTimer, () =>
        runWithAbortMonitor(() => handler(handlerEvent), abortSignal)
      )
    )
  })
})
```

</Tab>
</Tabs>

Event-level timeout finalization keeps cancellation semantics explicit:
- pending handlers -> cancelled
- started handlers -> aborted

## Note on retry

Bus/event timeouts are outer budgets. If you need per-attempt limits for retried handlers, use the `retry` decorator's `timeout` option.
