---
title: Events Suck
description: A gentle, mildly sarcastic bridge from imperative code to event-driven systems.
---

If you have ever seen "event-driven architecture" and immediately remembered a production incident from 2019, this page is for you.

The `events_suck` helpers exist to make event adoption less painful:

- Keep your existing imperative mental model.
- Keep method-shaped APIs that look like normal SDK/client code.
- Introduce events behind the curtain so you can migrate incrementally.

No ideology required. No ceremony tax. No "rewrite everything first."

## What `events_suck` gives you

| Helper | Python | TypeScript | What it does |
| --- | --- | --- | --- |
| `wrap(class_name, methods)` | Yes | Yes | Builds a client class with imperative methods that emit events and return the first result. |
| `make_events(mapping)` | Yes | Yes | Creates event classes from a mapping of event names to functions/methods. |
| `make_handler(func)` | Yes | No | Adapts a normal function/method into a handler that reads payload fields as function args. |

TypeScript intentionally does not have `make_handler`; the recommended pattern is explicit inline handlers.

## Pattern 1: Keep an imperative SDK surface with `wrap(...)`

Use this when you want `client.create(...)` and `client.update(...)` style calls while moving execution to events.

<Tabs>
<Tab title="Python">

```python
from bubus import BaseEvent, EventBus, events_suck

class CreateUserEvent(BaseEvent[str]):
    name: str
    age: int

class UpdateUserEvent(BaseEvent[bool]):
    id: str
    age: int | None = None

bus = EventBus('SDKBus')
bus.on(CreateUserEvent, lambda e: f'user-{e.age}')
bus.on(UpdateUserEvent, lambda e: e.age == 46)

SDKClient = events_suck.wrap('SDKClient', {
    'create': CreateUserEvent,
    'update': UpdateUserEvent,
})
client = SDKClient(bus=bus)

user_id = await client.create(name='bob', age=45, nickname='bobby')
updated = await client.update(id=user_id, age=46, source='sync')
```

</Tab>
<Tab title="TypeScript">

```ts
import { BaseEvent, EventBus, events_suck } from 'bubus'
import { z } from 'zod'

const CreateUserEvent = BaseEvent.extend('CreateUserEvent', {
  name: z.string(),
  age: z.number(),
  event_result_type: z.string(),
})
const UpdateUserEvent = BaseEvent.extend('UpdateUserEvent', {
  id: z.string(),
  age: z.number().nullable().optional(),
  event_result_type: z.boolean(),
})

const bus = new EventBus('SDKBus')
bus.on(CreateUserEvent, async (event) => `user-${event.age}`)
bus.on(UpdateUserEvent, async (event) => event.age === 46)

const SDKClient = events_suck.wrap('SDKClient', {
  create: CreateUserEvent,
  update: UpdateUserEvent,
})
const client = new SDKClient(bus)

const user_id = await client.create({ name: 'bob', age: 45 }, { nickname: 'bobby' })
const updated = await client.update({ id: user_id ?? 'fallback-id', age: 46 }, { source: 'sync' })
```

</Tab>
</Tabs>

## Pattern 2: Generate events from existing function signatures

Use this when you have legacy service methods and want event classes without manually writing each one.

<Tabs>
<Tab title="Python">

```python
from bubus import EventBus, events_suck

class LegacyUserService:
    def create(self, id: str | None, name: str, age: int) -> str:
        return f'{name}-{age}'

    def update(self, id: str, age: int | None = None, **extra) -> bool:
        return True

events = events_suck.make_events({
    'UserCreateEvent': LegacyUserService.create,
    'UserUpdateEvent': LegacyUserService.update,
})

service = LegacyUserService()
bus = EventBus('LegacyBus')
bus.on(events.UserCreateEvent, events_suck.make_handler(service.create))
bus.on(events.UserUpdateEvent, events_suck.make_handler(service.update))
```

</Tab>
<Tab title="TypeScript">

```ts
import { EventBus, events_suck } from 'bubus'

const events = events_suck.make_events({
  UserCreateEvent: (payload: { id: string | null; name: string; age: number }) => `${payload.name}-${payload.age}`,
  UserUpdateEvent: (payload: { id: string; age?: number | null }) => true,
})

const bus = new EventBus('LegacyBus')
bus.on(events.UserCreateEvent, ({ id, name, age }) => `${name}-${age}`)
bus.on(events.UserUpdateEvent, ({ id, age, ...extra }) => true)
```

</Tab>
</Tabs>

## Suggested migration flow

1. Wrap one painful integration surface with `events_suck.wrap(...)`.
2. Keep old method signatures and behavior stable for callers.
3. Move internal logic behind bus handlers one endpoint at a time.
4. Add richer event-native features later (forwarding, history, retries, middleware) only where they help.

## Reality check

You are not wrong if event systems have burned you before.

`events_suck` is designed for teams that want practical migration mechanics, not architecture cosplay. Keep the API shape people already trust, then adopt events at your own pace.
